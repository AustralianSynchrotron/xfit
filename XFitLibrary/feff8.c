/***********************************************************************}
{                                                                       }
{  This file contains routines used to interface to FEFF 8.20           }
{  Based on file for FEFF6.01 by Paul Ellis.  Originally copied from
{  that file by James Hester, May 2003
{                                                                       }
{***********************************************************************/

#if !defined (__FEFF8_C)

#define __FEFF8_C

#include <stdio.h>
#if defined(WIN32)
#include <windows.h>
#include <process.h>
#include <direct.h>
#define PATH_MAX 256       /* defined for us by Linux? */
#else
#include <unistd.h>        /* for fork, exec */
#include <sys/wait.h>      /* for waiting */
#include <dirent.h>        /* for accessing directories */
#endif
#include <sys/types.h>

#include <sys/stat.h>      /* for directory creation modes */

#include "feff8.h"

#include "console.h"

int pcopy (char path [], char from [], char to []);

int premove (char path [], char name []);

FILE * pfopen (char path [], char name [], char mode []);


char * FEFF8_name (char format [], int P, int A, double C []) {

  static char name [32];

  return name;

  }


  /*********************************************************************}
  {                                                                     }
  {  Given the following numbers (in the indicated ranges) :            }
  {                                                                     }
  {      number:      0 .. 719                                          }
  {      symmetry:    0 .. 989                                          }
  {                                                                     }
  {      x:         -45 .. 44                                           }
  {      y:         -45 .. 44                                           }
  {      z:         -45 .. 44                                           }
  {                                                                     }
  {  this routine generates a unique 6-character ASCII atom label       }
  {                                                                     }
  {  Avoid using :   32 (SPACE)                                         }
  {                  34 (")                                             }
  {                  39 (')                                             }
  {                  44 (COMMA)                                         }
  {                 127 (BACKSPACE)                                     }
  {                                                                     }
  {*********************************************************************/

char * FEFF8_label (int number, int symmetry, int x, int y, int z) {

  static char label [7];

  int i;

  number   = min (max (number, 0), 719);
  symmetry = min (max (symmetry, 0), 989);

  x = min (max (x, -45), 44);
  y = min (max (y, -45), 44);
  z = min (max (z, -45), 44);

  label [0] = 33 + number % 90;
  label [1] = 33 + symmetry % 90;
  label [2] = 33 + (number / 90) + (symmetry / 90) * 8;

  label [3] = x + 78;
  label [4] = y + 78;
  label [5] = z + 78;

  for (i = 0; i < 6; i++) {

    label [i] += (label [i] >= '\"');
    label [i] += (label [i] >= '\'');
    label [i] += (label [i] >= ',');
    label [i] += (label [i] >= '\\');

    }

  label [6] = 0;

  return label;

  }


  /*********************************************************************}
  {                                                                     }
  {  Given a label generated by FEFF8_label, this routine will          }
  {  translate it back into the original numbers                        }
  {                                                                     }
  {*********************************************************************/

int translate_FEFF8_label (char label [], int * number,

                           int * symmetry, int * x, int * y, int * z) {

  int u [6], i;

  if (!strncmp (label, "      ", 6))

    return 0;

  for (i = 0; i < 6; i++) {

    u [i] = (unsigned) (label [i]);

    u [i] -= (u [i] > '\\');
    u [i] -= (u [i] > ',');
    u [i] -= (u [i] > '\'');
    u [i] -= (u [i] > '\"');

    }

  if (number)

    *number   = u [0] - 33 + ((u [2] - 33) % 8) * 90;

  if (symmetry)

    *symmetry = u [1] - 33 + ((u [2] - 33) / 8) * 90;

  if (x)

    *x = u [3] - 78;

  if (y)

    *y = u [4] - 78;

  if (z)

    *z = u [5] - 78;

  return 1;

  }


  /*********************************************************************}
  {                                                                     }
  {  Find the instance "instance" of the atom with atomic number ZC.    }
  {                                                                     }
  {  This is the central atom.                                          }
  {                                                                     }
  {  If ZC is 0, use the first atom.                                    }
  {                                                                     }
  {  If the instance does not exist, return 0.                          }
  {                                                                     }
  {*********************************************************************/

int rationalise_FEFF8_potentials (char name [],

                                   double ZC, int instance,

                                   int shells, double potential [],

                                               double Z []) {

  int shell0, shell, shellC, potentials;

  char * done, temp [256];

  if (shells <= 256)

    done = temp;

  else

    done = calloc_check (shells, sizeof (char));

  ZC = floor (ZC + 0.5);

  for (shell = 0; shell < shells; shell++)

    done [shell] = 0;


    /* Find the central atom */

  for (shellC = 0; ZC && shellC < shells; shellC++)

    if (Z [shellC] == ZC) {

      if (instance <= 0)

        break;

      instance--;

      }

  if (instance != 0 || shellC >= shells) {

    if (done != temp)
    
      free_check (done);

    return 0;

    }


    /* Change the potentials to be 0 = central, 1, 2, 3 .... */

  potential [shellC] = 0;

  done [shellC] = 1;

  for (potentials = 1, shell0 = 0; shell0 < shells; shell0++)

    if (!done [shell0]) {

      for (shell = shells - 1; shell >= shell0; shell--)

        if (!done [shell] &&
             potential [shell] == potential [shell0] &&
             Z [shell] == Z [shell0]) {

          potential [shell] = potentials;

          done [shell] = 1;

          }

      potentials++;

      }

  if (done != temp)
  
    free_check (done);

  return potentials;

  }


  /*********************************************************************}
  {                                                                     }
  {  Create a FEFF8 input file.                                         }
  {                                                                     }
  {*********************************************************************/

int make_FEFF8 (char name [],

                 char path [],

                 double ZC, int instance, int hole,

                 double polar  [],
                 double normal [],
                 double ellipticity,

                 int    max_legs,
                 double max_length,

                 double dE,
                 double dEi,

                 double filter_CW,
                 double filter_PW,

                 int    shells,
                 double potential [],
                 double Z         [],
                 double N         [],
                 double v         [][3],
                 double s         [],

                 double S02) {

  FILE * feff_inp;

  int shell0, shell, shellC, ipotential, potentials, number;

  double * Z_potential, d, current_d, next_d;

  for (shell = 0; shell < shells; shell++)

    Z [shell] = floor (Z [shell] + 0.5);

  potentials = rationalise_FEFF8_potentials (name, ZC, instance, shells,
                                                       potential, Z);

  if (potentials == 0)

    return 0;


    /* Open the file */

  feff_inp = pfopen (path, "feff.inp", "w");

  if (feff_inp == NULL) {

    cwarn (" make_FEFF8 (%s): can't open %s\\feff.inp",  name, path);

    return 0;

    }


    /* Check the polarisation information */

  if (polar)

    if (normalise3 (polar) == 0)

      polar = normal = NULL;

  if (normal)

    if (normalise3 (normal) == 0)

      normal = NULL;

  if (ellipticity == 0)

    normal = NULL;


    /* Find the Z corresponding to each potential */

  Z_potential = calloc_check (potentials, sizeof (double));

  for (shell = 0; shell < shells; shell++) {

    if (potential [shell] == 0)

      shellC = shell;

    Z_potential [(int) potential [shell]] = Z [shell];

    }


    /* Print the file */

  fprintf (feff_inp, "* FEFF 8 command file generated by %s\n\n", name);

  fprintf (feff_inp, "CONTROL 1 1 1 1\n");

/* Note: feff6 -> feff7; the FEFFNNNN.dat files are no longer written by
   default; we set the final value to 3.  It may be more appropriate to
   try to read the binary file? */

/*  fprintf (feff_inp, "PRINT   0 0 0 0\n\n");  /* FEFF6 style */
  fprintf (feff_inp, "PRINT   0 0 0 3\n\n");  /* FEFF7 style */

  fprintf (feff_inp, "HOLE         %3d       %9.5f\n", hole, S02);

  fprintf (feff_inp, "SIG2           0.00000\n");

  if (polar)

    fprintf (feff_inp, "POLARIZATION %9.5f %9.5f %9.5f\n",
                                     polar [0], polar [1], polar [2]);

  if (normal)

    fprintf (feff_inp, "ELLIPTICITY  %9.5f %9.5f %9.5f %9.5f\n",
                                     ellipticity,
                                     normal [0], normal [1], normal [2]);


  fprintf (feff_inp, "CRITERIA     %9.5f %9.5f\n", filter_CW, filter_PW);

  fprintf (feff_inp, "NLEG         %3d\n", max_legs);

  fprintf (feff_inp, "RPATH        %9.5f\n", max_length);/* FEFF6 has RMAX */

  fprintf (feff_inp, "CORRECTIONS  %9.5f %9.5f\n", dE, dEi);

  fprintf (feff_inp, " \nPOTENTIALS\n");

  for (ipotential = 0; ipotential < potentials; ipotential++)

    fprintf (feff_inp, "     %3d  %3.0f\n",
                        ipotential, Z_potential [ipotential]);

  fprintf (feff_inp, " \nATOMS\n");

  for (shell = 0; shell < shells; shell++)

    fprintf (feff_inp, " %15.10f %15.10f %15.10f %3.0f\n",
                        v [shell][0], v [shell][1], v [shell][2],
                        potential [shell]);


    /* in FEFF8, we do not need to specify the OVERLAP for every 
       unique atomic potential: this differs from FEFF6/7 */

  fprintf (feff_inp, " \nEND\n");

  fclose (feff_inp);

  free_check (Z_potential);

  return 1;

  }


int ExecFEFF8 (char path []) {

#if !defined(WIN32)
  pid_t child_id;
  int current_status;
  int status;
#else
  STARTUPINFO si;
  DWORD result;
  PROCESS_INFORMATION Proc;
  char win_message[256];   /* for debug messages */
  unsigned long Code;       /* a 32 bit word */
#endif

#if !defined(WIN32)
/* We replace the Windows call with a unix fork and exec.
   This is a definite architecture-dependent bit */

  child_id = fork();
  if(child_id == -1) {   /* error */
      printf("Error forking to Feff8\n");
      return -1;
  }
  if(child_id != 0) waitpid(child_id, &current_status, 0);
  else {  /* in child */
      /* change to the proper working directory */
      status = chdir(path);
      if(status!=0) {
          printf("Failed to change to %s\n",path);
          return -1;
          }
      printf ("Forking to feff8...\n");
      status = execlp("feff820",NULL);
      if(status!=0) {           /* shouldn't be here */
          printf("Executing feff8 failed: status %d\n",status);
          return -1;
      }
  }

  if(WIFEXITED(current_status)) return WEXITSTATUS(current_status);
  else return -1;
  
#else    /* Windows */
  memset(&si,0,sizeof(si));  /* blank startup information */
  si.cb = sizeof(si);
  sprintf(win_message,"Executing feff820 in directory %s\n",path);
  debug_out(win_message);
  result = CreateProcess (NULL, "feff820", NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS,
                 NULL, path, &si, &Proc);
  if (result == 0) {
	  debug_out("Error starting feff8:");
	  return -1;
  }
  sprintf(win_message,"Feff8 execution result %ld\n",result);
  debug_out(win_message);
  do {
	  result = WaitForSingleObject (Proc.hProcess, 100);
  } while (result == WAIT_TIMEOUT);
  sprintf(win_message,"Wait result now %#0lx, \n",result);
  debug_out(win_message);
  result = GetExitCodeProcess (Proc.hProcess, &Code);
  sprintf(win_message,"Got exit code %#0lx, result %ld\n",Code,result);
  debug_out(win_message);
  return Code;
#endif
  }


  /*********************************************************************}
  {                                                                     }
  {  Create a directory to run FEFF8 in.                                }
  {                                                                     }
  {*********************************************************************/

char * FEFF8_directory () {

/* JRH comments.  We try to get the directory name from environment variables
   TEMP and TMP.  On Windows, we must have a full colon, so if we con't get 
   one returned (ie a bogus value) we skip it.  If both these methods fail,
   we choose the current working directory.  We test in each case to make
   sure we can open the directory; if this fails, we return NULL.  Finally,
   we generate a temporary name using the tmpnam POSIX call, and this 
   becomes the directory name.  Under Linux, we simply call tmpnam and
   then make this directory */
   

#if defined(WIN32)

  char * tmpdir, * dir;
  int dirp;       /* flag from _chdir test */

  char filename [L_tmpnam];

  tmpdir = getenv ("TEMP");

  if (tmpdir)

    if (!strchr (tmpdir, ':'))

      tmpdir = NULL;

  if (tmpdir) {

    dirp = _chdir (tmpdir);

    if (dirp!=0)             /* failed */

      tmpdir = NULL;

    }

  if (!tmpdir) {
  
    tmpdir = getenv ("TMP");

    if (tmpdir)
  
      if (!strchr (tmpdir, ':'))

        tmpdir = NULL;

    if (tmpdir) {

      dirp = _chdir (tmpdir);

      if (dirp!=0)

        tmpdir = NULL;

      }
    }

  if (!tmpdir)

    tmpdir = _getcwd (NULL, 0);

  if (!tmpdir)

    return NULL;

  tmpnam (filename);

  dir = malloc (strlen (tmpdir) + 1 + strlen (filename) + 1 + PATH_MAX + 1);

  strcpy (dir, tmpdir);
  /* strcat (dir, "\\"); */
  strcat (dir, filename);

  _mkdir (dir);

  AllocConsole ();

#endif
#ifdef __USE_POSIX

   
  static char dir [L_tmpnam];    /* don't allocate on stack */
 
  tmpnam(dir);  

  if(mkdir(dir,S_ISUID|S_ISGID|S_IRUSR|S_IWUSR|S_IXUSR)!=0) { 
     printf("Unable to create directory %s for FEFF8\n",dir);
     return NULL;
     }

#endif  /* __USE_POSIX */

  return dir;
  }


  /*********************************************************************}
  {                                                                     }
  {  Execute FEFF8.  The executable must be in the PATH or in the       }
  {  directory specified by FEFF_DIRECTORY.                             }
  {                                                                     }
  {*********************************************************************/

int execute_FEFF8 (char name [],

                    char path [],

                    int potph, int paths, int genfmt, int ff2chi,

                    int print) {

  long i;

  FILE * feff_inp;

  char line [256], * p;


    /* if print is 0, then route the output of FEFF to /dev/null */

  if (potph)

    potph = 1;

  if (paths)

    paths = 1;

  if (genfmt)

    genfmt = 1;

  if (ff2chi)

    ff2chi = 1;


    /* Modify the CONTROL card in feff.inp */

  feff_inp = pfopen (path, "feff.inp", "r+");

  if (feff_inp == NULL) {

    cwarn ("execute_FEFF8 (%s): can't open %s\\feff.inp", name, path);

    return 0;

    }

  while (p = fgets (line, 256, feff_inp)) {

    if (!strncmp (line, "CONTROL", 7)) {

        /* Go back to the beginning of the line */
	/* Windows and GNU differ by one character; presumably
	   this is related to the end-of-line characters */
#if defined(WIN32)
	  fseek (feff_inp, -strlen (line)-1, SEEK_CUR);
#endif
#if defined(__GNUC__)
	  fseek (feff_inp, -strlen(line), SEEK_CUR);
#endif
      fprintf (feff_inp, "CONTROL %1d %1d %1d %1d",
                          potph, paths, genfmt, ff2chi);

      break;

      }
    }

  fclose (feff_inp);

  if (p == NULL) {

    cwarn ("execute_FEFF8 (%s): %s\\feff.inp is missing the CONTROL card", name, path);

    return 0;

    }


    /* Execute FEFF8 */

  i = ExecFEFF8 (path);

  if (i != 0)

    cerror ("Abnormal termination (%d): %s", i, path);

  return i == 0;

  }


  /*********************************************************************}
  {                                                                     }
  {  Clean up after FEFF8.                                              }
  {                                                                     }
  {*********************************************************************/

int clean_FEFF8 (char name [], char path []) {

#if !defined(WIN32)
	DIR * dirp;

  struct dirent * direntp;

  if (path) {
      
    dirp = opendir (path);

    if (dirp) {

      while (1) {

        direntp = readdir (dirp);

        if (direntp) {

          if (strcmp (direntp->d_name, ".") && strcmp (direntp->d_name, ".."))

            premove (path, direntp->d_name);

          }
        else

          break;
        }

      closedir (dirp);
	  return rmdir(path) == 0;
	}
  }
#else
	  _chdir(path);
	  _rmtmp();


      FreeConsole ();

      return rmdir (path) == 0;

#endif

  return 0;

}

int read_FEFF8_path (char wpath [], FILE * paths_dat, path_l * path) {

  int leg, l;

  char line [256];


  path->number = 
  path->legs   = 
  path->points = 
  path->match  =
  path->use    = 0;

  path->next = NULL;

  if (!fgets (line, 256, paths_dat))

    return 0;

  if (sscanf (line, " %d %d %lf",
              &(path->number), &(path->legs), &(path->degeneracy)) <= 0)

    return 0;

  fgets (line, 256, paths_dat);


    /* Read in the leg vertices

       (shift by one position to put the initial atom at the start) */

  for (leg = 1; leg <= path->legs; leg++) {

    l = leg % path->legs;

    path->Z [l] = 0;

    path->potential [l] = -1;

    if (fgets (line, 256, paths_dat))

      sscanf (line, " %lf %lf %lf %lf",
                    &(path->v [l][0]), &(path->v [l][1]),
                    &(path->v [l][2]), &(path->potential [l]));

    if (path->potential [l] < 0) {

      cwarn ("read_FEFF8_path (%s\\path.dat): error reading path %d", wpath, path->number);

      return -1;

      }
    }

  path->use = 1;

  return 1;

  }

  /*********************************************************************}
  {                                                                     }
  {  Read paths from paths.dat and feffxxxx.dat into the list           }
  {                                                                     }
  {  If the path exists, it is overwritten.                             }
  {                                                                     }
  {  All paths are in numerical order.                                  }
  {                                                                     }
  {*********************************************************************/

int read_FEFF8_paths (char wpath [], path_l ** path_list, int read_data,

                int Nam,

                double potentialm [], double Zm [], double Rm [][3]) {

  FILE * paths_dat, * feff_dat;

  path_l path;

  path_l * entry;

  int i, l, imin;

  double d, dmin;

  char filename [16], line [256];


  paths_dat = pfopen (wpath, "paths.dat", "r");

  if (!paths_dat)

    cerror ("read_paths: can't open %s\\paths.dat", wpath);


  readheader (paths_dat, NULL, 0);

  while (read_FEFF8_path (wpath, paths_dat, &path) > 0) {

      /* Find the entry with the correct index or add a new one */

    for (; *path_list; path_list = &((*path_list)->next))

      if ((*path_list)->number >= path.number)

        break;

 
    if (*path_list == NULL)

      *path_list = calloc_check (1, sizeof (path_l));

    else

      if ((*path_list)->number > path.number) {

        entry = *path_list;

        *path_list = calloc_check (1, sizeof (path_l));

        (*path_list)->next = entry;

        }

    entry = *path_list;


      /* Copy the path parameters */

    entry->number = path.number;

    entry->points = 0;

    entry->degeneracy = path.degeneracy;

    entry->legs = path.legs;


      /* Find the atoms on the paths */

    for (l = 0; l < path.legs; l++) {

        /* Get the nearest atom with the correct potential */

      for (dmin = MAXDOUBLE, imin = 0, i = 0; i < Nam; i++)

        if (floor (path.potential [l] + 0.5) == floor (potentialm [i] + 0.5)) {

          d = distance3 (path.v [l], Rm [i]);

          if (d < dmin) {

            imin = i;
            dmin = d;

            }
          }

      entry->atom [l] = imin;

      entry->v [l][0] = Rm [imin][0];
      entry->v [l][1] = Rm [imin][1];
      entry->v [l][2] = Rm [imin][2];

      entry->Z [l]    = Zm [imin];

      }


    for (l = 0; l < path.legs; l++)

      entry->potential [l] = path.potential [l];



      /* If required, get the exafs curves */

    if (read_data) {

      sprintf (filename, "feff%04d.dat", path.number);

      feff_dat = pfopen (wpath, filename, "r");

      if (feff_dat) {

        readheader (feff_dat, NULL, 0);


          /* Discard the parameters of the atoms in the path */

        for (l = 0; l < entry->legs + 3; l++)

          fgets (line, 256, feff_dat);


          /* Read the EXAFS parameter curves */

        for (i = 0; !feof (feff_dat) && i < MAXPOINTS;)

          if (fgets (line, 256, feff_dat))

            if (sscanf (line, " %lf %lf %lf %lf %lf %lf %lf\n",

                          &(entry->k)          [i],
                          &(entry->real_2_phc) [i],
                          &(entry->mag_feff)   [i],
                          &(entry->phase)      [i],
                          &(entry->red_factor) [i],
                          &(entry->lambda)     [i],
                          &(entry->real_p)     [i]) > 0)

              i++;

        entry->points = i;

        fclose (feff_dat);

        /* premove (wpath, filename); */  /*leave in for later checking */

        }
      }
    }

  fclose (paths_dat);

  premove (wpath, "paths.dat");

  if (read_data)

    premove (wpath, "files.dat");

  return 1;

  }


int write_FEFF8_path (char wpath [], FILE * paths_dat, path_l * path) {

  int l0, leg, l1, l2, l;

  double R_eff, R_leg, vertex, torsion;

  for (R_eff = 0, leg = 0; leg < path->legs; leg++)

     R_eff += distance3 (path->v [leg], path->v [(leg + 1)
                                                  % path->legs]);

  R_eff /= 2;

  fprintf (paths_dat, "%6d%5d%8.3f  index, nleg, degeneracy, r=%8.4f\n",
                path->number, path->legs, path->degeneracy, R_eff);

  fprintf (paths_dat, "      x           y           z     ipot"
                      "  label      rleg      beta        eta\n");


    /* Write out the leg vertices

       (shift by one position to put the initial atom at the end) */

  for (leg = 1; leg <= path->legs; leg++) {

    l0 = (leg + path->legs - 1) % path->legs;
    l  =  leg      % path->legs;
    l1 = (leg + 1) % path->legs;
    l2 = (leg + 2) % path->legs;

    R_leg = distance3 (path->v [l0], path->v [l]);

    vertex = vertex_angle3 (path->v [l0], path->v [l],
                                           path->v [l1]) * 180 / M_PI;

    torsion = torsion_angle3 (path->v [l0], path->v [l],
                          path->v [l1], path->v [l2]) * 180 / M_PI;

    fprintf (paths_dat, COORDINATE_FORMAT COORDINATE_FORMAT
                        COORDINATE_FORMAT
                        "%4.0f \'%s\' %10.4f%10.4f%10.4f\n",
                        path->v [l][0], path->v [l][1],
                        path->v [l][2], path->potential [l],
                        "      ", R_leg, vertex, torsion);

    }

  return 1;

  }


int save_FEFF8_files (char name [], char path [], int phase, int index) {

  char phases [32];

  sprintf (phases, PHASE_NAME, index);

  if (phase)

    if (pcopy (path, "phase.bin", phases) != 0)

      cerror ("save_FEFF8_files (%s): can't copy %s\\phase.bin -> %s\\%s",
                    name, path, path, phases);

  return 1;

  }


  /*********************************************************************}
  {                                                                     }
  {  Manage the binary phaseshift files                                 }
  {                                                                     }
  {             (phase.bin / ph<index>.bin / phases<index>.bin)         }
  {                                                                     }
  {*********************************************************************/

int manage_FEFF8_files (char name [], char path [], int calc, int index) {

  static int Current_Phase = -1;

  char c [32];


    /* Clean */

  if (index < 0) {

    Current_Phase = -1;

    return 1;

    }


    /* Save the current phase file if the index has changed */

  if (Current_Phase >= 0 && index != Current_Phase) {

    sprintf (c, PHASE_NAME, Current_Phase);

    if (prename (path, "phase.bin", c) != 0)

      cerror ("manage_FEFF8_files (%s): can't rename %s\\phase.bin -> %s\\%s",
                                              name, path, path, c);

    Current_Phase = -1;

    }


    /* If the phases are being recalculated, delete the phase file */

  if (calc) {

    if (index == Current_Phase)

      premove (path, "phase.bin");

    else {

      sprintf (c, PHASE_NAME, index);

      premove (path, c);

      }

    Current_Phase = index;

    }


    /* If the phases are not being recalculated, rename the phase file */

  if (!calc && Current_Phase != index) {

    sprintf (c, PHASE_NAME, index);

    if (prename (path, c, "phase.bin") != 0)

      cerror ("manage_FEFF8_files (%s): can't rename %s\\%s -> %s\\phase.bin",
                                                       name, path, path, c);

    Current_Phase = index;

    }


  return 1;

  }


  /*********************************************************************}
  {                                                                     }
  {  Rewrite the paths.dat file with the new coordinates (R [][3]).     }
  {                                                                     }
  {  The paths are taken from the path list passed.  Only the marked    }
  {  paths are used.                                                    }
  {                                                                     }
  {  If no paths are written, the file is deleted.                      }
  {                                                                     }
  {*********************************************************************/

int rewrite_FEFF8_paths (char name [], char wpath [], path_l * path, int all,

                         double R [][3],

                         int * count) {

  FILE * paths_dat;

  double v_o [MAXLEGS][3];

  int l;

  /* printf (" rewrite_FEFF8_paths (\"%s\", %p, %d, ...)\n", name, path, all); */

  *count = 0;

  paths_dat = pfopen (wpath, "paths.dat", "w");

  if (paths_dat == NULL) {

    cwarn ("rewrite_FEFF8_paths (%s): can't open %s\\paths.dat", name, wpath);

    return 0;

    }


    /* In this version, print an empty header */

  fprintf (paths_dat, " ---------------------------------------"
                      "----------------------------------------\n");


    /* Write each path */

  for (; path; path = path->next) {

    static char onumber [32], nnumber [32];

    int match, i, OK;


    path->match = 0;

    if (!path->use)

      continue;


      /* Compare the old and new coordinates for this path.

         (Do these look the same when written in the format
          (COORDINATE_FORMAT) used in write_FEFF8_path?) */

    for (match = !all, l = 0; l < path->legs && match; l++)

      for (i = 0; i < 3 && match; i++) {

        sprintf (onumber, COORDINATE_FORMAT, path->v [l][i]);
        sprintf (nnumber, COORDINATE_FORMAT, R [path->atom [l]][i]);

        match = !strcmp (onumber, nnumber);

        /* printf (" \"%s\" - \"%s\" : %d\n", onumber, nnumber, match); */

        }

    if (match) {

      path->match = 1;

      continue;

      }


      /* Save and update the coordinates */

    for (l = 0; l < path->legs; l++) {

      v_o [l][0] = path->v [l][0];
      v_o [l][1] = path->v [l][1];
      v_o [l][2] = path->v [l][2];

      path->v [l][0] = R [path->atom [l]][0];
      path->v [l][1] = R [path->atom [l]][1];
      path->v [l][2] = R [path->atom [l]][2];

      }


      /* Write the path */

    OK = write_FEFF8_path (wpath, paths_dat, path);


      /* Restore the coordinates */

    for (l = 0; l < path->legs; l++) {

      path->v [l][0] = v_o [l][0];
      path->v [l][1] = v_o [l][1];
      path->v [l][2] = v_o [l][2];

      }


    if (!OK) {

      cwarn ("error writing %s\\paths.dat", wpath);

      fclose (paths_dat);

      return 0;

      }


    (*count)++;

    }

  fclose (paths_dat);

  if (*count == 0)

    premove (wpath, "paths.dat");

  return 1;

  }

#endif /* __FEFF8_C */

